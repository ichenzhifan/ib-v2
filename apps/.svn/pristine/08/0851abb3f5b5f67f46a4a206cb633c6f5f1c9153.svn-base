import React, { Component, PropTypes } from 'react';
import classNames from 'classnames';
import { merge } from 'lodash';

import XModal from '../../../../common/ZNOComponents/XModal';
import XButton from '../../../../common/ZNOComponents/XButton';
import XSelect from '../../../../common/ZNOComponents/XSelect';
import './index.scss';

class OptionsModal extends Component {
  constructor(props) {
    super(props);
    // setting 为当前项目的信息对象，包含 size、type、product、title 等属性
    const { setting } = this.props;
    // 在 state 中为当前弹框中的数据设置缓存区
    this.state = {
      title: setting.title,
      type: setting.type,
      size: setting.size,
      warntipShow: false,
      warnMes: '',
      typeMap: [],
      sizeMap: []
    };

    this.handleTitleChange = this.handleTitleChange.bind(this);
    this.handleTypeChange = this.handleTypeChange.bind(this);
    this.handleSizeChange = this.handleSizeChange.bind(this);
    this.handleResetProject = this.handleResetProject.bind(this);
    this.handleCheckTitle = this.handleCheckTitle.bind(this);
  }
  // 当再一次点开的option 弹框时，根据当前 state 与 props 比较确定是否需要更新 state。
  componentWillReceiveProps(nextProps) {
    this.setState({ warntipShow: false });
    const { title, type, size } = this.state;
    if (title !== nextProps.setting.title || type !== nextProps.setting.type ||
    size !== nextProps.setting.size) {
      this.setState({
        title: nextProps.setting.title,
        type: nextProps.setting.type,
        size: nextProps.setting.size
      });
    }
    //  将源数据中的键名改为 XSelect组件需要的label 和 value 形式。
    const { optionMap } = nextProps;
    if (optionMap && optionMap.type) {
      let typeMap = [];
      let sizeMap = [];
      let squareSize = [];
      let landscapeSize = [];
      let portraitSize = [];
      // 更改typeMap 数组的键名
      typeMap = optionMap.type.map((item) => {
        return {
          value: item.id,
          label: item.name
        };
      });
      // 更改 sizeMap数组的键名
      sizeMap = optionMap.size.map((item) => {
        return {
          value: item.id,
          label: item.name
        };
      });
      // 更改 sizeMap在页面中的显示文字
      sizeMap.forEach((item) => {
        if (item.value.split('X')[0] - 0 === item.value.split('X')[1] - 0) {
          item.label = '(Square) ' + item.label;
          squareSize.push(item);
        } else if (item.value.split('X')[0] - 0 > item.value.split('X')[1] - 0) {
          item.label = '(Portrait) ' + item.label;
          portraitSize.push(item);
        } else if (item.value.split('X')[0] - 0 < item.value.split('X')[1] - 0) {
          item.label = '(Landscape) ' + item.label;
          landscapeSize.push(item);
        }
      });
      // 将 square/landscape/portrait/三种不同的size 在 sizeMap 中区分显示。
      sizeMap = squareSize.concat(landscapeSize).concat(portraitSize);
      this.setState({
        typeMap: typeMap,
        sizeMap: sizeMap
      });
    }
  }
  // 当 title 输入框内容变化时候将值 同步到 state.title
  handleTitleChange(event) {
    this.setState({ title: event.target.value });
  }
  // 当 type 下拉框内容改变时将值同步到 state.type
  handleTypeChange(value) {
    this.setState({ type: value.value });
  }
  // 当 size 下拉框内容改变时将值同步到 state.size
  handleSizeChange(value) {
    this.setState({ size: value.value });
  }
  // 当title 输入框失焦时检验 title 格式并向服务器发送数据校验重名。
  handleCheckTitle() {
    if (!this.state.title) {
      this.setState({
        warntipShow: true,
        warnMes: 'Incorrect format,please try again.'
      });
      return;
    } else if (!(/^[a-zA-Z 0-9\d_\s]+$/.test(this.state.title))) {
      this.setState({
        warntipShow: true,
        warnMes: 'Only letters, numbers, blank space and _ (underscore) are allowed in the title.' });
      return;
    }
  }
  // 当点下 done 按钮时，将 state 中的状态同步到 数据模型中
  handleResetProject() {
    // title 检测，首先检测 title 为空，然后检测 title 是否符合规则。
    if (!this.state.title || !this.state.title.trim()) {
      this.setState({
        warntipShow: true,
        warnMes: 'Incorrect format,please try again.'
      });
      return;
    } else if (!(/^[a-zA-Z 0-9\d_\s]+$/.test(this.state.title))) {
      this.setState({
        warntipShow: true,
        warnMes: 'Only letters, numbers, blank space and _ (underscore) are allowed in the title.' });
      return;
    }
    // 根据 title/type/size 是否改变来发送 action 更改 store 中 setting 对应的数据。
    const { boundProjectActions, onClosed, setting } = this.props;
    let submitData = {};
    if (this.state.title !== setting.title) { merge(submitData, { title: this.state.title }); }
    if (this.state.type !== setting.type) { merge(submitData, { type: this.state.type }); }
    if (this.state.size !== setting.size) { merge(submitData, { size: this.state.size }); }
    // 仅当title/type/size 三项至少有一项发生变化时才发送 action。
    if (this.state.title !== setting.title || this.state.type !== setting.type ||
      this.state.size !== setting.size) {
      boundProjectActions.changeProjectSetting(submitData);
    }
    // 关闭当前 options 弹窗组件
    onClosed();
  }

  render() {
    const { onClosed, opened } = this.props;
    const className = classNames('format-tip', { 'show-inline': this.state.warntipShow });
    return (
      <XModal
        className="options-modal"
        onClosed={onClosed}
        opened={opened}
      >
        <div className="option-modal-name">Options</div>
        <div className="options-modal-title">
          <p className={className}>{this.state.warnMes}</p>
          <label htmlFor="options-modal-title" >Title:</label>
          <input
            type="text"
            id="options-modal-title"
            value={this.state.title}
            onChange={this.handleTitleChange}
            onBlur={this.handleCheckTitle}
          />
        </div>
        <div className="options-modal-panneltype">
          <label>Panel Type:</label>
          <div className="select-wrap">
            {/*
                <select
                  value={this.state.type}
                  onChange={this.handleTypeChange}
                >
                 {
                    optionMap && optionMap.type
                    ? optionMap.type.map((item, index) => {
                      return (
                        <option value={item.id} key={index}>{ item.name }</option>
                      );
                    })
                    : null
                 }
                </select>
            */}
            <XSelect
              options={this.state.typeMap}
              searchable={false}
              onChanged={this.handleTypeChange}
              value={this.state.type}
            />
          </div>
        </div>
        <div className="options-modal-size">
          <label>Size:</label>
          <div className="select-wrap">
            {/*
              <select
                value={this.state.size}
                onChange={this.handleSizeChange}
              >
                {
                  optionMap && optionMap.size
                  ? optionMap.size.map((item, index) => {
                    return (
                      <option value={item.id} key={index}>{ item.name }</option>
                    );
                  })
                  : null
                }
              </select>
            */}
            <XSelect
              options={this.state.sizeMap}
              searchable={false}
              onChanged={this.handleSizeChange}
              value={this.state.size}
            />
          </div>
        </div>
        <div className="options-modal-button">
          <XButton
            onClicked={this.handleResetProject}
          >Done</XButton>
        </div>
      </XModal>
   );
  }
}

OptionsModal.propTypes = {
  optionMap: PropTypes.object,
  setting: PropTypes.object.isRequired,
  boundProjectActions: PropTypes.object.isRequired,
  onClosed: PropTypes.func.isRequired,
  opened: PropTypes.bool.isRequired
};

export default OptionsModal;

import React, { Component, PropTypes } from 'react';
import { merge, template, isEqual } from  'lodash';

// 导入用于本地化的组件
import { translate } from "react-translate";

import { getBorderLinesXY, getWrapLinesXY, getSpineThicknessLinesXY } from '../../../../common/utils/line';
import { makeId } from '../../../../common/utils/math';
import { getDefaultCrop } from '../../../../common/utils/crop';
import classNames from 'classnames';
import { IMAGES_CROPPER_PARAMS } from '../../contants/apiUrl';
import { getWrapBoxes } from '../../../../common/utils/draw';
import XElements from '../../../../common/ZNOComponents/XElements';
import XBGElement from '../../../../common/ZNOComponents/XBGElement';
import XPhotoElement from '../../../../common/ZNOComponents/XPhotoElement';
import XTextElement from '../../../../common/ZNOComponents/XTextElement';
import XHandler from '../../../../common/ZNOComponents/XHandler';
import XLines from '../../../../common/ZNOComponents/XLines';
import XBoxes from '../../../../common/ZNOComponents/XBoxes';

import './index.scss';

class Spread extends Component {
  constructor(props) {
    super(props);

    const state = this.initSpread(this.props);
    this.state = state;
  }

  componentWillReceiveProps(nextProps) {
    if (!this.state.liveUpdateCropImageUrl
      || !isEqual(this.props.imagesOptions, nextProps.imagesOptions)
      || !isEqual(this.props.spreadOptions, nextProps.spreadOptions)) {
      this.setState(this.initSpread(nextProps));
    }
  }

  initSpread(props) {
    const { spreadOptions, imagesOptions } = props;
    const { width, height } = spreadOptions;

    // 获取各种线的坐标.
    const lineWidth = 1;
    const borderLines = getBorderLinesXY(width, height, lineWidth, '#bcbcbc', true, 10);

    // 包括包边和出血区域在当前的case中, 因为没有设计出血线.
    const wrapLines = getWrapLinesXY(width, height, spreadOptions.wrapSize + spreadOptions.bleedTop, lineWidth, '#95989a');
    const spineThicknessLines = getSpineThicknessLinesXY(width, height, spreadOptions.spineThicknessWidth, lineWidth, '#bcbcbc', true, 12);

    // photo元素的options设置
    const photoOptions = imagesOptions ? merge({}, spreadOptions, {
      lineWidth,
      imageUrl: imagesOptions.url ? this.combineImgCopperUrl(imagesOptions, width, height) : ''
    }, {
      wrapSize: spreadOptions.wrapSize + spreadOptions.bleedTop,
      bleedTop: 0,
      bleedBottom: 0,
      bleedLeft: 0,
      bleedRight: 0
    }) : {};

    // 包边区域元素的options设置
    const boxesOptions = merge({}, spreadOptions, {
      wrapSize: spreadOptions.wrapSize + spreadOptions.bleedTop,
      bleedTop: 0,
      bleedBottom: 0,
      bleedLeft: 0,
      bleedRight: 0
    });

    // 获取上下左右四个包边区域的坐标和宽高信息
    const boxes = getWrapBoxes(width,
      height,
      'rgba(0, 0, 0, 0.05)',
      boxesOptions.bleedTop,
      boxesOptions.bleedBottom,
      boxesOptions.bleedLeft,
      boxesOptions.bleedRight,
      boxesOptions.wrapSize,
      lineWidth);

    const state = {
      lineWidth,
      borderLines,
      wrapLines,
      spineThicknessLines,
      photoOptions,
      boxesOptions,
      boxes,
      liveUpdateCropImageUrl: imagesOptions.url
    };
    return state;
  }

  /**
   * 获取用于裁剪的图片地址.
   */
  combineImgCopperUrl(imageOptions, targetWidth, targetHeight) {
    let url = '';

    // 根据原图的宽和高, 已经目标区域的宽和高, 计算裁剪时的比例.
    const cropParams = getDefaultCrop(imageOptions.width, imageOptions.height, targetWidth, targetHeight);

    // 调用lodash的template方法, 动态的替换里面的变量.
    url = template(imageOptions.url + IMAGES_CROPPER_PARAMS)(merge({}, imageOptions, cropParams, {
      rotation: 0
    }));

    return url;
  }

  render() {
    const { className, spreadId, spreadOptions } = this.props;
    const { width, height, bgColor, textInCenter } = spreadOptions;

    const customClass = classNames('spread', className);

    // spread的样式
    const styles = {
      width: `${width}px`,
      height: `${height}px`
    };


    return (
      <div className={customClass} style={styles}>
        <XElements>
          {/* 背景元素, 设置画布背景 */}
          <XBGElement canvasId={makeId(spreadId)}
                      bgColor={bgColor}
                      width={width}
                      height={height}
                      textInCenter={textInCenter}
          />

          {/* 图片元素, 用于渲染图片 */}
          <XPhotoElement canvasId={makeId(spreadId)}
                         width={width}
                         height={height}
                         options={this.state.photoOptions}>

            {/* 控制元素, 用于控制渲染出来的图片, 如缩放, 旋转等 */}
            <XHandler />
          </XPhotoElement>

          {/* 文本元素, 用于渲染文本 */}
          <XTextElement>

            {/* 控制元素, 用于控制渲染出来的文本, 如缩放, 旋转等 */}
            <XHandler />
          </XTextElement>

        </XElements>

        {/* 四个包边区域 */}
        <XBoxes canvasId={makeId(spreadId)}
                width={width}
                height={height}
                boxes={this.state.boxes}
        />

        {/* 线条元素, 用于绘制各种线条 */}
        <XLines canvasId={makeId(spreadId)}
                width={width}
                height={height}
                lines={[...this.state.borderLines, ...this.state.wrapLines, ...this.state.spineThicknessLines]}
        />
      </div>
    );
  }
}

Spread.propTypes = {
  spreadId: PropTypes.string.isRequired,

  // spread的参数设置
  spreadOptions: PropTypes.shape({
    textInCenter: PropTypes.string,
    bgColor: PropTypes.string,
    width: PropTypes.number,
    height: PropTypes.number,
    bleedTop: PropTypes.number,
    bleedBottom: PropTypes.number,
    bleedLeft: PropTypes.number,
    bleedRight: PropTypes.number,
    spineThicknessWidth: PropTypes.number,
    wrapSize: PropTypes.number,
  }).isRequired,

  // 在spread上绘制图片的参数设置.
  imagesOptions: PropTypes.shape({
    width: PropTypes.number,
    height: PropTypes.number,
    encImgId: PropTypes.string,
    url: PropTypes.string,
    imageId: PropTypes.string
  }).isRequired,

  onClicked: PropTypes.func,
  className: PropTypes.string
};

// 要导出的一个translate模块.
// - 第一个括号里的参数对应的是资源文件中定义的.
// - 第一个括号里的参数对应的是你要导出的组件名.
export default translate('Spread')(Spread);
